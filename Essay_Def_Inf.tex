\documentclass{article}
\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
%\usepackage[utf8]{inputenc}
\usepackage{mathtext}
\usepackage[english, russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{float}
\usepackage[margin=0.8in]{geometry}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage[utf8x]{inputenc} % указать кодировку русского текста
\usepackage{fancyhdr}
\usepackage{indentfirst} % отступ в первой строке абзаца
\usepackage{wrapfig}
\usepackage{placeins}

\usepackage{array}
\usepackage{makecell}
\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1}}

\usepackage{tikz}
\newcommand\diag[4]{%
	\multicolumn{1}{p{#2}|}{\hskip-\tabcolsep
		$\vcenter{\begin{tikzpicture}[baseline=0,anchor=south west,inner sep=#1]
				\path[use as bounding box] (0,0) rectangle (#2+2\tabcolsep,\baselineskip);
				\node[minimum width={#2+2\tabcolsep},minimum height=\baselineskip+\extrarowheight] (box) {};
				\draw (box.north west) -- (box.south east);
				\node[anchor=south west] at (box.south west) {#3};
				\node[anchor=north east] at (box.north east) {#4};
		\end{tikzpicture}}$\hskip-\tabcolsep}}

\pagestyle{fancy}
\begin{document}
	\begin{titlepage}
		\begin{center}
			%\vspace*{1cm}
			\large{\small ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ\\ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ\\ МОСКОВСКИЙ ФИЗИКО-ТЕХНИЧЕСКИЙ ИНСТИТУТ\\ (НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ)}
			\vfill
			\line(1,0){430}\\[1mm]
			\huge{Эссе}\\
			\huge\textbf{Crystals-Dilithium}\\
			\line(1,0){430}\\[1mm]
			\vfill
			\begin{flushright}
				\normalsize{Бобров Александр}\\
				\normalsize{\textbf{Группа Б01-904}}\\
			\end{flushright}
		\end{center}
	\end{titlepage}
	\section{
			Введение
	}

	Широко используемые на сегодняшний день ассиметричные системы шифрования основаны на двух типах задач теории чисел:
	\begin{itemize}
		\item факторизация целых чисел (RSA, схема Эль-Гамаля);
		\item дискретное логарифмирование (семейство алгоритмов Дефи-Хелмана).
	\end{itemize}

	Обращение этих задач считалось носуществивым за разумное время по причине отсутствия полиноминальных алгоритмов по времени выполнения. Но начиная с 1995-го года начинается период "квантовой революции" в теории алгоритмов.
	
	В 1995 г. Питер Шор продемонстрировал полиномиальные алгоритмы
	обращения описанных выше задач на квантовых компьютерах [1]. В 1996 г. Гровер продемонстрировал общий метод поиска в базе дан-
	ных со сложностью $O(\sqrt{N})$, позволяющий реализовывать расшифровку
	симметричных алгоритмов шифрования эквивалентную двукратному у-
	меньшению ключа шифра [2].На практике работа алгоритма была провере-
	на на 2-х кубитном квантовом компьютере, состоящем из полумиллитра
	смеси изотопа карбона-13 помеченного хлороформом, находящегося в ацетоне-D6 [3].
	
	Так, получается, что используемые на практике системы ассиметричного шифрования, как и основная стадия шифрования - хеширование перестали быть сложными для обращения. Как следствие, возникла потребность поиска задач и алгоритмов, основанных на этих задачах, решение и расшифрование которых не было бы возможно с помощью квантовых компьютеров.
	
	\section{
			SVP, NTRU
	}
	Такой задачей стала SVP (shortest vector problem). Это задача о нахождении кратчайшего вектора в дискретной целочисленной решётке, которая может быть представлена как множество векторов заданных целочисленными линейно независимыми базовыми векторами (все компоненты каждого вектора вычисляются по модулю некоторого целого числа). Основные преимущества этой задачи:
	\begin{itemize}
		\item возможность построить одностороннюю функцию с секретом, быстро обращаемую при наличии дополнительных сведений (trapdoor function);
		\item не разрешима за полиноминальное время даже на квантовых вычислителях;
		\item SVP является NP-полной задачей.
	\end{itemize}

	Первое свойство позволяет значительно ускорить генерацию ключей и вычисление подписей на решётках (скорость генерации ключа и подписи(проверки подписи) улучшается с $O(n^2)$ до $O(n)$ ). Второе и третье свойства гарантируют сложность взлома алгоритмов, построенных SVP.
	
	Разновидностью SVP является CVP (closest vector problem). Это задача о нахождении вектора в решётке, ближайшего к выбранному (Найти вектор $\boldsymbol{x}$ такой, что он даёт  минимальное расстояние до выбранного вектора $\boldsymbol{v}$ в выбранно решётке $\boldsymbol{L}$).
	Алгоритм Crystalls-Dilithium использует в своей основе как раз CVP. Кроме того, в этом алгоритме используется алгоритм, аналогичный NTRU.\\
	
	NTRU - это система шифрования, основанная на задаче NTRU-свёртки модулярных решёток, которая является частным случаем CVP-задачи (итог - частный случай частного случая). Основой шифрования является опе-
	рация свертки на кольце модулярных многочленов (с целыми коэффициен-
	тами). Под сверткой многочленов в данном случае понимают, их умноже-
	нием, с заданным правилом свертки $x^i=1$, где $i=const$. Например, $x^5=1$:
	$(2x^4-3x^3+2)(4x^5+2x-2)=-2x^4-6x^3+4x+8$\\
	Под модулярным многочленом $Z[x]/(x^n-1)$ $modk$, понимают многочлен $P_{k}(x)=b_{n-1}x^n-1+...+b_{1}x+b_{0}$ коэффициенты которого являются остатком
	от деления, коэффициентов исходного многочлена \\
	$P(x)=b_{n-1}x^n-1+...+b_{1}x+b_{0}$ на $k$ и принадлежащие некоторому промежутку: $c_{1} \leq b_{i} \leq c_{2}$. Обратным многочленом $P_{k}(x)$ по модулю $k$ явялется многчлен $P_{k}^{-1}(x) : P_{k}^{-1}(x) * P_{k}(x) = 1$ $modk$.
	
	Тогда процесс шифрования будет заключаться в:
	\begin{itemize}
		\item выборе простого n, показателя степени для правила свертки, малого и большого взаимно простых модулей q и p;
		\item выборе многочленов $f(x), g(x) \in R$ c «малыми коэффициентами»;
		\item  вычислении обратных многочленов $F_{q}(x)=f^{-1}(x)$ $modq$
		\end{itemize}
	
	Публичным ключом является многочлен $h(x)=g(x)*F_{q}$ $modq$, приватным - многочлен $f(x)$.
	
	Шифрование
	
	Для шифрования текста, представляемого многочленом $m(x)$ $modp$ выбирается "малый" многочлен $r(x)$. Тогда сообщение шифруется по формуле $e = p*r*h + m$ $modq$.
	
	Расшифровка
	
	Для расшифровки вычисляется $a(x)=e(x) * f(x)$ $modq$, коэффициента этого многочлена будут $A \leq a_{i} < A + q$. Тогда исходное сообщение восстанавливается по формуле $m(x)=F_{p}*a$ $modp$.
	
	
	\section{
		Fiat-Shamir heuristic
	}
	Ещё один протокол, который нужен для построения алгоритма Crystalls-Dilithium - это протокол Фиата-Шамира с прерываниями. На примере доказательства знания дискретного логарифма какого-то числа покажем поэтапную работу протокола:\\
	
	1. Алиса хочет доказать, что знает число $x$, которое является дискретным логарифмом y, $y = g^x (modn)$, также стороны заранее договариваются о выбранном простом числе $q$.\\
	
	2. Алиса берёт случайное число из кольца по модулю $q$ ($\mathbf{Z^*_{q}}$) и вычисляет $t=g^v$.\\
	
	3.Алиса вычисляет хеш-функцию $c=\mathbf{H}(g,y,t)$.\\
	
	4.Алиса вычисляет $r=v-cx$ \space $mod\lambda(q)$, здесь $\lambda(q)$ - это количество простых чисел от 1 до $q$. Результатом является доказательство (ключ) - пара $(t,r)$.\\
	
	5. Теперь, имея эту пару, кто угодно, знающий $x$, может доказать знание Алисы, вычислив истинность выражения $t=g^ry^c$.\\
	
	Знание хеш-функции, числа $q$ и случайного числа $v$ считаются открытыми, тогда проверку сможет осуществить любой, имеющий эти знания, знания о значении $x$ и знания о паре-доказательстве, выданному Алисой.\\
	Кроме этого, важно, чтобы значение хэщ-функции зависело от значения $y$, так как иначе атакующий может подобрать любое подходящее значение $y$, так чтобы узнать значение $cx$. На практике применяется раундовый (итеративный) протокол Фиата-Шамира: проводится несколько раундов (пункты 1-5), и если все арунды завершаются подтверждением, то знание считается доказанным.
	\\
	В алгоритме Crystalls-Dilithium используется протокол Фиата-Шамира с прерываниями. Дело в том, что задача(svp), на которой основан этот алгоритм решается приближённым методом, поэтому невозможно всегда гарантировать нахождение правильного решения. Для таких случаев используется протокол Фиата-Шамира с отбрасываниями. Его идея заключается в том, чтобы доказать истинность знания не во всех раундах проверки, а только в части из них (например, в $\frac{2}{3}$ всех раундов проверки). Кроме того, может случиться и так, что вычисления займут слишком много времени. Чтобы не тратить лишние ресурсы, используются отбрасывания некоторых раундов. 


\section{Crystals-Dilithium, упрощённая схема
}
	
	Здесь будут рассмотрены три этапа урощённой схемы алгоритма Crystals-Dilithium - генерация ключей, подпись и верификация.
	
	Ниже приведена схема упрощённого алгоритма, а ещё ниже приведено подробное объяснение каждого шага алгоритма.
	
	\includegraphics{picture}
	
	\begin{itemize}
	\item Генерация ключей происходит в 4 этапа:
		\begin{itemize}
			\item генерация случайной матрицы $\mathbf{A}$ размера $k \times l$. Эта матрица состоит из полиномов в кольце $R_{q}=\mathbf{Z_{q}}[X]/(X^n+1)$;
			\item генерация двух случайных секретных ключей - векторов $\mathbf{s_{1}}$ и $\mathbf{s_{2}}$. Каждый коэффициент этих векторов (множитель перед базисным вектором) - это элемент $R_{q}$, не больший заранее выбранного $\eta$. Размерность $\mathbf{s_{1}}$ - $l$, размерность $\mathbf{s_{2}}$ - $k$;
			\item на следующем шаге генерируется вторая часть открытого ключа как $\mathbf{t}= 	\mathbf{A}\mathbf{s_{1}} + \mathbf{s_{2}}$;
		
			\item открытым ключом является набор $(\mathbf{A}, \mathbf{t})$, закрытым - набор $(\mathbf{A}, 	\mathbf{t}, \mathbf{s_{1}}, \mathbf{s_{2}})$.
		\end{itemize}
	
	\item Подпись:
		\begin{itemize}
			\item алгоритм подписания генерирует вектор-маску из полиномов с коэффициентами меньше, чем $\gamma_{1}$. Параметр $\gamma_{1}$ выбран так, что он достаточно большой, чтобы не раскрыть секретный ключ(алгоритм с нулевым знанием или zero-knowledge algorithm), но достаточно маленький, чтобы подпись нелегко было подделать;
			\item после этого подписывающий вычисляет $\mathbf{A}\mathbf{y}$ и "биты высших порядков" (самые старшие биты этого произведения) записываются в $\mathbf{w_{1}}$. В самом деле, каждый коэффициет $w$ в $\mathbf{A}\mathbf{y}$ может быть записан как $w=w1*2\gamma_{2} + w_{0}$, где $|w_{0}| \leq \gamma_{2}$. Тогда интуитивно понятно, что $\mathbf{w}$ - это вектор, собирающий в себе все $w_{1}$;
			\item тогда "испытание" $c$ создаётся как хэш исходного сообщения и $\mathbf{w}$. Результатом будет многочлен в $R_{q}$ с кожффициентами равными $\pm1$ или $0$, причём количество $\pm$ обозначим как $\tau$ (на будущее). Это сделано для того, чтобы $c$ имеет малую норму и размером от 128 до 256;
			\item после этого потенциальная подпись вычисляется как \\
			$\mathbf{z}=\mathbf{y} +c\mathbf{s_{1}}$;
		\end{itemize}
	Если бы $\mathbf{z}$ сразу выводился, до схема подписи была бы небезопасной, так как в этом случае происходила бы утечка секретного ключа. Чтобы избежать зависимости $\mathbf{z}$ от секретного ключа, мы используем подбор с отказом (как в разобранном протоколе Фиата-Шамира). Требуется обозначить условие условие, когда мы отбрасываем подпись и вычисляем новую.
	
	Пусть параметр $\beta$ - это максимально возможный коэффициет в $c\mathbf{s_{i}}$. Так как $c$ содержит в себе ровно $\tau$ 1 и -1, то $\beta \leq \tau * \eta$. Если какой-то коэффициент $\mathbf{z}$ больше, чем $\gamma_{1} - \beta$, то процедура подписи начинается заново. Кроме этого условия, есть ещё одно: если какой-то коэффициент младших битов $\mathbf{A}\mathbf{z} - c\mathbf{t}$ больше, чем $\gamma_{2} - \beta$.
	
	Первое условие важно только для безопасности подписи, тогда как второе - и для безопасности, и для правильности алгоритма. Параметры кольца q и n позволяют добиться правильной подписи за небольшое число итераций (примерно 4 итерации для $q = s^33 - 2^13 +1, n = 256$).
	\item Проверка подписи:
		\begin{itemize}
			\item проверющий вычисляет вектор $\mathbf{w_{1}^{'}}$ - вектор старших битов от $\mathbf{A}\mathbf{z}-c\mathbf{t}$ и подтверждает подпись, если все коэффиуиенты $\mathbf{z}$ меньше, чем $\gamma_{1} - \beta$ и $c$ - это результат хэш-функции сообщения и $\mathbf{w_{1}^{'}}$
		\end{itemize}
	\end{itemize}
	
	\section{
			Улучшения упрощённой схемы
	}
	Самое заметное (но легко исправляемое) улучшение - это замена матрицы $r \times l$, состоящей из многочленов, в публичном ключе, так как её представление занимает очень много места в памяти. Решение: заменить матрицу $\mathbf{A}$ на семя $\rho$, с помощью которого алгоритм SHAKE-128 генерирует нужную нам матрицу. Тогда открытый ключ - это набор $(\rho,\mathbf{t})$, и его размер продиктован, в основном, размером $\mathbf{t}$. 
	
	Кроме этого, Dilithium уменьшает размер битового представления $\mathbf{t}$ немного больше, чем в два раза ценой увеличения подписи почти на сто байтов. При подтверждении подписи, $\mathbf{w_{1}^{'}}$ не сильно зависит от младших битов $\mathbf{t}$, потому что $\mathbf{t}$ умножен на на очень "незначительный" (малые весса у коэффициентов) многочлен $c$. В приведённой схеме некоторые младшие биты $\mathbf{t}$ не включены в публичный ключ, и проверяющий не может всегда правльно посчитать старише биты $\mathbf{A}\mathbf{z}-c\mathbf{t}$. Для этого подписывающий добавляет "подсказки" как часть подписи, которые существенно помогают, добавляя в произведение с $c$ недостающие младшие биты $\mathbf{t}$. С этой подпаской можно правильно посчитать $\mathbf{w_{1}^{'}}$.
	
	Также можно рассмотреть улучшение общего случая умножения матрицы $\mathbf{A}$. Её элементы - полиномы в $\mathbf{Z_{q}}[X]/(X^{256}+1)$, которые умножаются на вектор $\mathbf{y}$ таких же многочленов. Как и во многих алгоритмах, основанных на решётках, кольцо можно выбрать так, чтобы умножение производилось очень эффективной операцией с помощью дискретного преобразовани Фурье. Для этого нужно выбрать простое $q$ так, чтобы группа $\mathbf{Z_{q}^{*}}$ обладала элементом порядка $2n=512$, или (что то же самое) $q=1$ $mod512$. Если r такой элемент, то $X^{256}+1=(X-r)(X_r^3)...(X-r^511)$ и следовательно, возможно эквивалентное представление любого полинома $a \in \mathbf{Z_{q}}[X]/(X^{256}+1)$ с помощью китайской теоремы об остатках в форме $(a(r), a(r^3),...,a(r^{2n-1}))$. Преимущество этого представления в том, что произведение двух полиномов происходит покоординатно (как в скалярном произведении двух векторов). Таким образом, самая дорогая часть перемножения многочленов - это преобразование $a \rightarrow \hat{a}$ и обратное преобразование $\hat{a} \rightarrow a$, а это известные и быстрые дискретные преобразования Фурье.
\newpage

\def\refname{
		Источники
}

\begin{thebibliography}{9} 
	\bibitem{1} Shor P.W., \emph{Polynomial-time algorithms for prime factorization and dis-
		crete logarithms on a quantum computer}. SIAM J. Com.,1997, 26:5,
		стр. 1484-1509.
\bibitem{2} Grover L. K., \emph{A fast quantum mechanical algorithm for database search, Proceedings of the 28th ACM STOC, 1996, стр. 212–219.
	}
\bibitem{3} Chuang I. L., Gershenfeld N., Kubinec M., \emph{Experimental Implementation
	of Fast Quantum Searching, Physical Review Letters, 1998, 80:15,
		стр. 3408–3411.
}
 \end{thebibliography} 

\end{document}